---
title: "King Auric's Options"
date: "6/20/2020"
author: "Aaron Ferrucci"
output:
  html_document:
    df_print: paged
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
---

```{r message=F, warning=F, echo=F}
library(dplyr)
library(ggplot2)
```
From [538 Riddler: Can You Flip The Magic Coin?](https://fivethirtyeight.com/features/can-you-flip-the-magic-coin/)

> From Dean Ballard comes a riddle of radiant spheres and fatherhood,
> just in time for the summer solstice and Father’s Day:
> 
> King Auric adored his most prized possession: a set of perfect spheres of
> solid gold. There was one of each size, with diameters of 1 centimeter, 2
> centimeters, 3 centimeters, and so on. Their brilliant beauty brought joy
> to his heart. After many years, he felt the time had finally come to pass
> the golden spheres down to the next generation — his three children.
> 
> He decided it was best to give each child precisely one-third of the
> total gold by weight, but he had a difficult time determining just how
> to do that. After some trial and error, he managed to divide his spheres
> into three groups of equal weight. He was further amused when he realized
> that his collection contained the minimum number of spheres needed for
> this division. How many golden spheres did King Auric have?
> 
> Extra credit: How many spheres would the king have needed to be able to
> divide his collection among other numbers of children: two, four, five,
> six or even more?

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Preliminaries
Thinking about the problem, what do we know?

* We need at least 3 balls (more generally, at least one ball per child)
* The weight of the gold balls is proportionate to the cube of the diameter. (I can work with cubed diameters (d3s) rather than actually ball weights.)
* The sum of the d3s must be a multiple of 3

### Nuts 'n' Bolts
How common is it to find a sum of d3s that's divisible by 3? 
```{r}
n <- 15
d3s <- seq(n)**3
sums <- cumsum(d3s)
sums %% 3
```

Looks like 2/3s of the sums are divisible by 3. So, a small optimization here: skip the 1/3 of cases which fail the divisible-by-3 test.


A solution to this problem (a brute force one, anyway) could rely on finding a subset of a list of numbers which sums to a specific value. Really brute force would be to compute each subset, do the sum, and compare. There's a better way via dynamic programming, I'm sure.

```{r}
library(utils)
for (i in seq(3, length(d3s)))
{
  if (sums[i] %% 3 == 0) {
    find_sum <- sums[i] / 3
    print(sprintf("searching for sub-sum %d in d3s up to index %d; sum: %d", find_sum, i, sums[i]))
    for (j in seq(1, i - 2)) {
      cur_d3s <- d3s[1:i]
      # to do: call with a FUN which returns the combination _if_ its sum is find_sum, else NA
      sub <- combn(cur_d3s, j)
      # print(sub)
      column_sums <- apply(sub, 2, sum)
      if (any(column_sums == find_sum)) {
        match1 <- as.matrix(sub[,column_sums == find_sum])
        for (k in seq(ncol(match1))) {
          print(sprintf("found matching sub-sum(s), size %d", j))
          print(match1[,k])
          compl <- cur_d3s[!cur_d3s %in% match1[,k]]
          print(sprintf("to do: can I find another sum %d in the complement list?", find_sum))
          print(compl)
        }
        print("that's out of this list:")
        print(cur_d3s)
      }
    }
    # print(paste("subset length", i))
    # combinations <- combn(d3s, i)
    # out <- combinations[,apply(combinations, 2, sum)>=threshold]
    # print (out)
  }
}
```
